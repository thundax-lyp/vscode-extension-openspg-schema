<div align="center"><a name="readme-top"></a>

<h1>OpenSPG Schema ANTLR4</h1>

[OpenSPG Schema](https://github.com/OpenSPG/KAG) Mark Language Lexer and Parser, generated by official ANTLR4 grammar.

[![NPM version][npm-image]][npm-url]
[![NPM downloads][download-image]][download-url]
[![Apache-2.0 License][license-shield]][license-url]

[![Contributors][contributors-shield]][contributors-url]
[![Issues][issues-shield]][issues-url]
[![Stargazers][stars-shield]][stars-url]

[Change Log](./CHANGELOG.md) · [Report Bug](https://github.com/thundax-lyp/vscode-extension-openspg-schema/issues/new) · [Pull Request](https://github.com/thundax-lyp/vscode-extension-openspg-schema/compare)

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

[npm-image]: https://img.shields.io/npm/v/openspg-schema-antlr4?style=for-the-badge

[npm-url]: http://npmjs.org/package/openspg-schema-antlr4

[download-image]: https://img.shields.io/npm/dm/openspg-schema-antlr4.svg?style=for-the-badge

[download-url]: https://npmjs.org/package/openspg-schema-antlr4

[license-shield]: https://img.shields.io/github/license/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[license-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/blob/main/LICENSE

[contributors-shield]: https://img.shields.io/github/contributors/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[contributors-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/graphs/contributors

[stars-shield]: https://img.shields.io/github/stars/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[stars-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/stargazers

[issues-shield]: https://img.shields.io/github/issues/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[issues-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/issues

</div>

## Installation

```bash
npm install openspg-schema-antlr4
```

> It will be `pnpm/yarn add openspg-schema-antlr4` if you use pnpm or yarn.

## Usage

### Language Parser

* `parse(code, [options])`: `parse()` parses the provided code as an entire Schema source unit.
* `options`:
    * `tolerant`: `boolean`, default is `false`. If `true`, the parser will try to parse as much as possible, even if the input is invalid, and never throw an error.
    * `selector`: `function`, default is `(p) => p.sourceUnit()`. If provided, the parser will only return the nodes that match the selector. It will be useful when you want to
      parse a specific node.
* `output`: `SyntaxNode`, the root node of the AST.

```js
// parse.mjs
import {parse} from 'openspg-schema-antlr4';

const code = `// Sample
namespace BaiKe

Person(人物): EntityType
    properties:
        desc(描述): Text
            index: TextAndVector
        semanticType(语义类型): SemanticConcept
        synonyms(同义词): Person
        officialName(标准名): Person

Transport(运输): EntityType
    properties:
        desc(描述): Text
            index: TextAndVector
        semanticType(语义类型): SemanticConcept
        synonyms(同义词): Transport
        officialName(标准名): Transport

Works(作品): EntityType
    properties:
        desc(描述): Text
            index: TextAndVector
        semanticType(语义类型): SemanticConcept
        synonyms(同义词): Works
        officialName(标准名): Works

Event(事件): EventType
    properties:
        subject(主体): Person
        participants(参与者): Person
            constraint: MultiValue
        time(时间): Date
        location(地点): GeographicLocation
        abstract(摘要): Text
            index: TextAndVector
        type(事件类型): Text
            index: Text
`;

const ast = parse(code, {tolerant: true, selector: (p) => p.sourceUnit()});

```

### Tokenizer

* `tokenizer(code, [options])`: `tokenizer()` parses the provided code as tokens.
* `options`:
    * `tolerant`: `boolean`, default is `false`.
* `output`: `SyntaxToken[]`.

```js
// tokenizer.mjs
import {tokenizer} from 'openspg-schema-antlr4';

const tokens = tokenizer(code, {tolerant: true});

```

### Traverse AST

We can use it alongside the parser to traverse nodes.

```js
import {parse, visit, serialize} from 'openspg-schema-antlr4';

const ast = parse(code);

// Use `visit` to traverse ast by enter/exit node type.
visit(ast, {
    enter: ({node, parent}) => {
        console.log(node.type, parent?.type); // print node type
    },
    exit: () => {
    }, // will call when exit node
    Identifier: ({node: identifierNode}) => {
        console.log(identifierNode.name); // print identifier name
    },
    exitContractDefinition: ({node: contractDefinitionNode}) => {
        // will call when exit ContractDefinition node
    }
});

// Use `serialize` to modify ast.
const newAST = serialize(ast, ({node}) => {
    // do something
    if (node.type === 'Identifier') {
        return node.name;
    }
    return node;
})
```

```js
// traverse.mjs
import {parse, traverse} from 'openspg-schema-antlr4';

const ast = parse(code);

const newAST = traverse(ast, (path) => {
    // path.path => `SourceUnit.Namespace` ...
    // path.node => current node
    // path.parentPath => parent node path
    // path.depth => current node depth
    // path.stop(); => stop traverse
    // path.rewrite({...}); => rewrite current node
    // path.matches({ type: 'xxx' }); => check if current node matches the given filter
    // return () => {}; => will call when exit node
});
```

### Low-level API

> Not recommended, but you can use it if you want.

```ts
import {SchemaLexer, SchemaParser, CharStreams, CommonTokenStream} from 'openspg-schema-antlr4';

const code = `...`; // code here

const input = CharStreams.fromString(code);
const lexer = new SolidityLexer(input);
const tokens = new CommonTokenStream(lexer);
const parser = new SolidityParser(tokens);

const parseTree = parser.sourceUnit();

// do something with parseTree
```

## License

[Apache](./LICENSE)
