<div align="center"><a name="readme-top"></a>

<h1>OpenSPG Concept-Rule ANTLR4</h1>

[OpenSPG Concept-Rule](https://github.com/OpenSPG/KAG) Language Lexer and Parser, generated by official ANTLR4 grammar.

[![NPM version][npm-image]][npm-url]
[![NPM downloads][download-image]][download-url]
[![MIT License][license-shield]][license-url]

[![Contributors][contributors-shield]][contributors-url]
[![Issues][issues-shield]][issues-url]
[![Stargazers][stars-shield]][stars-url]

[Change Log](./CHANGELOG.md) · [Report Bug](https://github.com/thundax-lyp/vscode-extension-openspg-schema/issues/new) · [Pull Request](https://github.com/thundax-lyp/vscode-extension-openspg-schema/compare)

![](https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png)

[npm-image]: https://img.shields.io/npm/v/openspg-concept-rule-antlr4?style=for-the-badge

[npm-url]: http://npmjs.org/package/openspg-concept-rule-antlr4

[download-image]: https://img.shields.io/npm/dm/openspg-concept-rule-antlr4.svg?style=for-the-badge

[download-url]: https://npmjs.org/package/openspg-concept-rule-antlr4

[license-shield]: https://img.shields.io/github/license/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[license-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/blob/main/LICENSE

[contributors-shield]: https://img.shields.io/github/contributors/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[contributors-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/graphs/contributors

[stars-shield]: https://img.shields.io/github/stars/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[stars-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/stargazers

[issues-shield]: https://img.shields.io/github/issues/thundax-lyp/vscode-extension-openspg-schema.svg?style=for-the-badge

[issues-url]: https://github.com/thundax-lyp/vscode-extension-openspg-schema/issues

</div>

## Installation

```bash
npm install openspg-concept-rule-antlr4
```

> It will be `pnpm/yarn add openspg-concept-rule-antlr4` if you use pnpm or yarn.

## Usage

### Language Parser

* `parse(code, [options])`: `parse()` parses the provided code as an entire Concept-Rule source unit.
* `options`:
    * `tolerant`: `boolean`, default is `false`. If `true`, the parser will try to parse as much as possible, even if the input is invalid, and never throw an error.
    * `selector`: `function`, default is `(p) => p.sourceUnit()`. If provided, the parser will only return the nodes that match the selector. It will be useful when you want to
      parse a specific node.
* `output`: `SyntaxNode`, the root node of the AST.

```js
// parse.mjs
import {parse} from 'openspg-concept-rule-antlr4';

const code = `// Sample
namespace Sample

\`TaxOfRiskUser\`/\`赌博App开发者\`:
    rule: [[
        Define (s:\`ProductChain\`.\`TaxonomyOfCompanyAccident\`/\`周期性行业头部上市公司停产事故\`)-[p: leadTo]->(o:\`ProductChain\`.\`TaxonomyOfIndustryInfluence\`/\`成本上升\`) {
            Structure {
                \`TaxOfRiskApp\`
            }
            Constraint {
                R("30天内浏览"): p.timestamp > -30
                o = group(s).count(u)
            }
            Action {
                downEvent = createNodeInstance(
                    type = ProductChain.IndustryInfluence,
                    value = {
                        subject = down.id
                    }
                )
                createEdgeInstance(
                    src = s,
                    dst = downEvent,
                    type = leadTo,
                    value = {
                    }
                )
            }
        }
    ]]
`;

const ast = parse(code, {tolerant: true, selector: (p) => p.sourceUnit()});

```

### Tokenizer

* `tokenizer(code, [options])`: `tokenizer()` parses the provided code as tokens.
* `options`:
    * `tolerant`: `boolean`, default is `false`.
* `output`: `SyntaxToken[]`.

```js
// tokenizer.mjs
import {tokenizer} from 'openspg-concept-rule-antlr4';

const tokens = tokenizer(code, {tolerant: true});

```

### Traverse AST

We can use it alongside the parser to traverse nodes.

```js
import {parse, visit, serialize} from 'openspg-concept-rule-antlr4';

const ast = parse(code);

// Use `visit` to traverse ast by enter/exit node type.
visit(ast, {
    enter: ({node, parent}) => {
        console.log(node.type, parent?.type); // print node type
    },
    exit: () => {
    }, // will call when exit node
    Identifier: ({node: identifierNode}) => {
        console.log(identifierNode.name); // print identifier name
    },
    exitContractDefinition: ({node: contractDefinitionNode}) => {
        // will call when exit ContractDefinition node
    }
});

// Use `serialize` to modify ast.
const newAST = serialize(ast, ({node}) => {
    // do something
    if (node.type === 'Identifier') {
        return node.name;
    }
    return node;
})
```

```js
// traverse.mjs
import {parse, traverse} from 'openspg-concept-rule-antlr4';

const ast = parse(code);

const newAST = traverse(ast, (path) => {
    // path.path => `SourceUnit.Namespace` ...
    // path.node => current node
    // path.parentPath => parent node path
    // path.depth => current node depth
    // path.stop(); => stop traverse
    // path.rewrite({...}); => rewrite current node
    // path.matches({ type: 'xxx' }); => check if current node matches the given filter
    // return () => {}; => will call when exit node
});
```

### Low-level API

> Not recommended, but you can use it if you want.

```ts
import {ConceptRuleLexer, ConceptRuleParser, CharStreams, CommonTokenStream} from 'openspg-concept-rule-antlr4';

const code = `...`; // code here

const input = CharStreams.fromString(code);
const lexer = new SolidityLexer(input);
const tokens = new CommonTokenStream(lexer);
const parser = new SolidityParser(tokens);

const parseTree = parser.sourceUnit();

// do something with parseTree
```

## License

[Apache](./LICENSE)
